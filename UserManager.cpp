#include "UserManager.h"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <ctime>
#include <random>
#include <algorithm>

UserManager* UserManager::instance = nullptr;

UserManager::UserManager(const std::string& filename) : dataFile(filename) {
    loadUsers();
}

UserManager* UserManager::getInstance(const std::string& filename) {
    if (instance == nullptr) {
        instance = new UserManager(filename);
    }
    return instance;
}

void UserManager::loadUsers() {
    std::ifstream file(dataFile);
    if (!file.is_open()) return;

    std::string line;
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string username, passwordHash, email, isAdminStr, walletId, balanceStr;
        
        std::getline(ss, username, ',');
        std::getline(ss, passwordHash, ',');
        std::getline(ss, email, ',');
        std::getline(ss, isAdminStr, ',');
        std::getline(ss, walletId, ',');
        std::getline(ss, balanceStr, ',');
        
        auto user = std::make_shared<User>(username, "", email, isAdminStr == "1");
        users.push_back(user);
    }
}

void UserManager::saveUsers() {
    std::ofstream file(dataFile);
    if (!file.is_open()) return;

    for (const auto& user : users) {
        file << user->getUsername() << ","
             << user->getEmail() << ","
             << (user->getIsAdmin() ? "1" : "0") << ","
             << user->getWalletId() << ","
             << user->getBalance() << "\n";
    }
}

bool UserManager::registerUser(const std::string& username, const std::string& password,
                             const std::string& email, bool isAdmin) {
    // Check if username already exists
    if (std::find_if(users.begin(), users.end(),
        [&](const auto& u) { return u->getUsername() == username; }) != users.end()) {
        return false;
    }

    auto user = std::make_shared<User>(username, password, email, isAdmin);
    users.push_back(user);
    saveUsers();
    return true;
}

bool UserManager::registerUserWithAutoPassword(const std::string& username,
                                             const std::string& email,
                                             bool isAdmin) {
    // Generate random password
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(0, 35);
    static const char* chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    
    std::string password;
    for (int i = 0; i < 8; ++i) {
        password += chars[dis(gen)];
    }
    
    auto user = std::make_shared<User>(username, password, email, isAdmin);
    user->setAutoGeneratedPassword(true);
    users.push_back(user);
    saveUsers();
    return true;
}

std::shared_ptr<User> UserManager::authenticateUser(const std::string& username,
                                                  const std::string& password) {
    auto it = std::find_if(users.begin(), users.end(),
        [&](const auto& u) { return u->getUsername() == username; });
    
    if (it != users.end() && (*it)->verifyPassword(password)) {
        return *it;
    }
    return nullptr;
}

bool UserManager::changeUserPassword(const std::string& username,
                                   const std::string& oldPassword,
                                   const std::string& newPassword) {
    auto user = authenticateUser(username, oldPassword);
    if (user) {
        user->changePassword(newPassword);
        saveUsers();
        return true;
    }
    return false;
}

bool UserManager::updateUserInfo(const std::string& username,
                               const std::string& newEmail) {
    auto it = std::find_if(users.begin(), users.end(),
        [&](const auto& u) { return u->getUsername() == username; });
    
    if (it != users.end()) {
        // Update email logic here
        saveUsers();
        return true;
    }
    return false;
}

std::vector<std::shared_ptr<User>> UserManager::getAllUsers() const {
    return users;
}

bool UserManager::deleteUser(const std::string& username) {
    auto it = std::find_if(users.begin(), users.end(),
        [&](const auto& u) { return u->getUsername() == username; });
    
    if (it != users.end()) {
        users.erase(it);
        saveUsers();
        return true;
    }
    return false;
}

void UserManager::createBackup() {
    auto now = std::time(nullptr);
    std::stringstream backupName;
    backupName << dataFile << ".backup_" << now;
    
    std::filesystem::copy_file(dataFile, backupName.str());
}

bool UserManager::restoreFromBackup() {
    // Find the most recent backup
    std::string mostRecentBackup;
    std::time_t mostRecentTime = 0;
    
    for (const auto& entry : std::filesystem::directory_iterator(".")) {
        std::string filename = entry.path().filename().string();
        if (filename.find(dataFile + ".backup_") == 0) {
            auto fileTime = std::filesystem::last_write_time(entry.path());
            auto time = std::chrono::system_clock::to_time_t(
                std::chrono::file_clock::to_sys(fileTime));
            
            if (time > mostRecentTime) {
                mostRecentTime = time;
                mostRecentBackup = filename;
            }
        }
    }
    
    if (!mostRecentBackup.empty()) {
        std::filesystem::copy_file(mostRecentBackup, dataFile,
                                 std::filesystem::copy_options::overwrite_existing);
        loadUsers();
        return true;
    }
    return false;
} 